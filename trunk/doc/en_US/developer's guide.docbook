<?xml version="1.0" encoding="UTF-8" standalone="yes"?>

<!-- $Id$ -->

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
          "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<book>
  <bookinfo>
    <title>Open eGovernment Developer's Guide</title>
    <authorgroup>
      <corpauthor>Open E-Government Team</corpauthor>
    </authorgroup>
    <copyright>
      <year>2009, 2010</year>
      <holder>Gerrit M. Albrecht</holder>
    </copyright>
    <legalnotice>
      <para>This work is licensed under the Creative Commons Attribution License. To view a copy of this license, visit <ulink url="http://creativecommons.org/licenses/by/2.5/">http://creativecommons.org/licenses/by/2.5/</ulink> or send a letter to Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.</para>
    </legalnotice>
  </bookinfo>

  <chapter>
    <title>Introduction for Developers</title>
    <section>
      <title>Overview</title>
      <para>.</para>
    </section>
    <section>
      <title></title>
      <para>.</para>
    </section>
  </chapter>

  <chapter>
    <title>Setup from Scratch</title>
    <section>
      <title>Overview</title>
      <para>This chapter describes the steps needed to get an environment for building
own applications with latest tools and without using prebuilt packages from this project.</para>
    </section>
    <section>
      <title>Preparation and Setup</title>
      <para>To build everything you first need a setup with some prebuilt stuff. Applications need e.g. gettext and it's simpler to use a binary version to build the "builder" package (which needs gettext). Later you may rebuild such applications and all of their dependent packages.
</para>
      <para>The first setup step is the installation of Qt. Retrieve a complete development package (with MinGW and precompiled libraries) from <ulink url="http://qt.nokia.com/">qt.nokia.com</ulink>, because it is all you need to be ready for working. Then download the Open eGovernment source package and extract it to any path you want. This is your base installation path. You don't need to set an environment variable. It's possible to put the directory structure onto an USB stick.</para>
      <para>To build applications you need a lot of standard tools and applications. Most of them only compile with patches or when other tools are available. So you have to build a nearly complete GNU toolchain.</para>
      <para>Independent binary tools may be downloaded from their respective websites. The following tools may be installed as binaries:
        <itemizedlist>
          <listitem><para>Git,</para></listitem>
          <listitem><para>Perl.</para></listitem>
        </itemizedlist>
      </para>
    </section>
  </chapter>

  <chapter>
    <title>Directory Structure</title>
    <section>
      <title>Overview</title>
      <para></para>
    </section>
    <section>
      <title>Packs</title>
      <para>Every package, OEG is able to use, can be found in the subdirectory "packs".
A pack is a package which contains download and build instructions, patches,
dependencies and other information used to compile a package and integrate
it into the OEG directory structure.</para>
      <para>The directory packs/archives contains binary archives which can be installed
without compiling them yourself. The packs/instructions contains files needed
to build a pack from zero. This directory needs to get recursively updated
every time you want to install something new in order to always use the latest
sources and instructions. The directory packs/downloads contains distributed
source codes downloaded from the homepages of the packs. It is not complete and contains only
rare files or files extracted from a repository.</para>
    </section>
  </chapter>

  <chapter>
    <title>Application Development</title>
    <section>
      <title>Overview</title>
      <para>Every application may, at its option, use Qt's or OEG's classes. It's recommended to
      make use of the (enhanced) OEG classes, which provide a lot of standard-offer capabilities
      already built-in. The common way to open your application's window is to derive a class from
      OEG::Qt::MainWindow.</para>
      <para>While development it may help to add "CONFIG += console" into your .pro file.</para>
    </section>

    <section>
      <title>Get Started</title>
      <para>The best method to get ready is using the template application.</para>
      <para></para>
      <programlisting language="c++"><![CDATA[  ]]></programlisting>
    </section>

    <section>
      <title>Compilation</title>
      <para></para>
    </section>

    <section>
      <title>Post Compilation Steps</title>
      <para>After compilation some additional build steps are executed. First, the newly build executable
      gets stripped to reduce the file size. This needs the strip.exe, usually found in the MinGW/MSYS
      environment. Next the application or DLL is marked to use Data Execution Prevention and Adress
      Space Layout Randomisation to avoid a to simple exploitation. This is done with the peflags.exe
      which has to exists in the bin folder in order to be used automatically. In a last step the application
      gets signed using a self-generated certificate. This ensures the official origin of it, but unfortunately
      it's a simple certificate and not one from a big trust center.</para>
    </section>
  </chapter>

  <chapter>
    <title>Well-known Error Messages</title>
    <section>
      <title>Old Include Files</title>
      <para>The compilation of standard applications should always run successfully because no non-functional software should be checked in into the repository. If nevertheless you experience any difficulties, it is often due to third party software. While compiling you may see such warnings:</para>
      <screen><![CDATA[# In file included from c:\Qt\2010.04\qt\include/QtCore/qglobal.h:1,
                 from c:\Qt\2010.04\qt\include/QtCore/../../src/corelib/global/q
namespace.h:45,
                 from c:\Qt\2010.04\qt\include/QtCore/qnamespace.h:1,
                 from c:\Qt\2010.04\qt\include/QtCore/../../src/corelib/kernel/q
objectdefs.h:45,
                 from c:\Qt\2010.04\qt\include/QtCore/qobjectdefs.h:1,
                 from c:\Qt\2010.04\qt\include/QtCore/../../src/corelib/kernel/q
object.h:47,
                 from c:\Qt\2010.04\qt\include/QtCore/qobject.h:1,
                 from c:\Qt\2010.04\qt\include/QtCore/../../src/corelib/kernel/q
coreapplication.h:45,
                 from c:\Qt\2010.04\qt\include/QtCore/qcoreapplication.h:1,
                 from c:\Qt\2010.04\qt\include\QtGui/../../src/gui/kernel/qappli
cation.h:45,
                 from c:\Qt\2010.04\qt\include\QtGui/qapplication.h:1,
                 from c:\Qt\2010.04\qt\include\QtGui/QApplication:1,
                 from ..\..\..\..\libraries/OEG/Qt/Application.h:7,
                 from MainWindow.cpp:3:
c:\Qt\2010.04\qt\include/QtCore/../../src/corelib/global/qglobal.h:1594: warning
: 'libintl_printf' is an unrecognized format function type
c:\Qt\2010.04\qt\include/QtCore/../../src/corelib/global/qglobal.h:1600: warning
: 'libintl_printf' is an unrecognized format function type
c:\Qt\2010.04\qt\include/QtCore/../../src/corelib/global/qglobal.h:1608: warning
: 'libintl_printf' is an unrecognized format function type
c:\Qt\2010.04\qt\include/QtCore/../../src/corelib/global/qglobal.h:1613: warning
: 'libintl_printf' is an unrecognized format function type]]></screen>
      <para>These indicate, that the include files of gettext are out of date. Install current libiconv and gettext packages to get rid of the message.</para>
    </section>

    <section>
      <title>Unused Variables</title>
      <para>If you see a warning about unused variables and want to get rid of it, you may disable them globally or (better) mark the variable as unused. E. g. if you open your MainWindow this warning may appear.</para>
      <code><![CDATA[MainWindow *mw __attribute__ ((__unused__)) = new MainWindow();]]></code>
      <para>A simpler solution (only in this case) is it, to place the call of the show() method after the definition.</para>
    </section>

    <section>
      <title>Untranslated texts are in English</title>
      <para>While translating and localizing your application it is possible, that gettext asks you to include 
      a --from-code=iso-8859-1. This means, it has found some text, which should be english (as all untranslated texts),
      but contains non-english characters. This may be an untranslated german text. Yes, this is a bug.</para>
    </section>

    <section>
      <title>HANDLE vs. Qt::HANDLE</title>
      <para>While compiling Windows API source code into a Qt library there may be errors because of ambigous variables
      where the compiler is unable to resolve the datatype HANDLE (is it ::HANDLE or Qt::HANDLE?). Don't try to
      mark the variables with ::, better is, to remove the "using namespace Qt;" line from the top of the file.
      It is only there to allow the use of Qt constants without a "Qt::" prefix.</para>
    </section>
  </chapter>

  <chapter>
    <title>Hints and Tips</title>
    <section>
      <title>Compile and Run</title>
      <para>After compilation the executables are created in the bin directory far away from the work directory.
      To run the application it is possible to add the target run to your make, e. g. type "mingw32-make run".
      This executes the newly created file.</para>
    </section>
  </chapter>

  <chapter>
    <title>DBUS Scripting</title>
    <section>
      <title>Overview</title>
      <para></para>
    </section>
  </chapter>

  <chapter>
    <title>JavaScript Scripting</title>
    <section>
      <title>Overview</title>
      <para></para>
    </section>
  </chapter>

  <chapter>
    <title>Data Storage</title>
    <section>
      <title>Overview</title>
      <para>Documents may be stored into databases and files. This is configurable. As databases at least MySQL and SQLite are always supported. The Database Manager is able backup, mix, update or convert databases between the different engines (e.g. MySQL/Inno-DB and MySQL/MyISAM), or applications (MySQL, SQLite). It allows to upgrade from one data format to another (but not back to an older!). This allows you to work first with SQLite-Databases and later switch to a real database management system if you really need one.</para>
    </section>

    <section>
      <title>MySQL</title>
      <para></para>
    </section>

    <section>
      <title>SQLite</title>
      <para></para>
    </section>

    <section>
      <title>XML Files for Documents</title>
      <para>Application may store their data into XML based documents. file allows the storage of documents in files. However, it's also possible
      to store them as binary blobs in a database, but in this case consider to use a real database.
      The advantage of XML files is to possibility to use them as sources for other areas of application.
      So you may generate derived data files using simple XSL scripts.</para>
    </section>

    <section>
      <title>Flat Files as Table Replacement</title>
      <para>Flat files are configured and handled like databases. Typical applications are for storage purposes, e.g. in the document management system or special applications. Think of a tree cadaster, where the database contains the (textual) data in SQLite files and you will not place the big fotos of the trees into your small database. Then you are able to select the "table" and put the entries with random names into a directory.</para>
    </section>
  </chapter>

  <chapter>
    <title>Database Support</title>
    <section>
      <title>Overview</title>
      <para>Applications may use databases as desired. Every OEG application may provide a database description in its
      application.xml file. This file informs OEG about the database to be used and (while compiling) a SQL file gets
      written which contains the initialzation code for an empty database. The database component is able to use it to
      create a new database or to update an existing database. Many applications come with pre-filled databases. Databases
      may be public (group or role-based spreading), private (role-based accesss) or official. Official databases may be
      updated from the OEG website. Others are spread by using peer-to-peer techniques or encrypted mail transfer.</para>
    </section>
  </chapter>

  <chapter>
    <title>Localization</title>
    <section>
      <title>Overview</title>
      <para>OEG uses GNU gettext and not Qt's internal translation system to provide localized messages and user
      interfaces. This allows you to make use of the proved and tested translation tools around gettext.</para>
      <para></para>
    </section>
  </chapter>
</book>

